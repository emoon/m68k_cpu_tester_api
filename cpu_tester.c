#include <stdint.h>
#include <string.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#define M68K_DATA_VERSION 4
#define M68K_INST_NAME_SIZE 16

typedef uint32_t u32;
typedef uint16_t u16;

// 80-bit register type
typedef struct M68KFpuReg {
    uint16_t exp;
    uint16_t dummy;
    uint32_t m[2];
} M68KFpuReg;

// Holds all the registers
struct M68KRegisters {
    uint32_t regs[16];
    uint32_t ssp;
    uint32_t msp;
    uint32_t pc;
    uint32_t sr;
    uint32_t exc;
    uint32_t excframe;
    M68KFpuReg fpuregs[8];
    uint32_t fpiar, fpcr, fpsr;
    uint32_t srcaddr, dstaddr;
} M68KRegisters;

typedef struct M68KTesterMemory {
	// memory in use
	uint8_t* buffer;
	// Backup memory of memory ptr, used for restoring the momry 
	const uint8_t* backup;
    // Memory start location in 32-bit address space 
    uint32_t address;
    // Memory end location in 32-bit address space 
    uint32_t end;
    // Size of test memory
    uint32_t size;
} M68KTesterMemory;  

typedef struct M68KMenemonicData {
    // the files generated by cputestgen has a version written in it so that needs to match with the loader code
    uint32_t version;
    // Hold time stamp of the written file. This is checked so the other data file matches this and nothing is out of data
    uint32_t start_time_id;
    // Start address for high-mem rom?
    uint16_t high_mem_rom;
    // Start address for low-mem rom?
    uint16_t low_mem_rom;
    // Start of opcode memory
    uint32_t opcode_memory_address;
    // CPU type to use
    uint32_t cpu_level;
    // Interrupts to test
    uint32_t interrupt_mask;
    // Addressing to test
    uint32_t addressing_mask;
    // Flag mode
    uint32_t flag_mode;
    // Status register undefined mask
    uint32_t sr_undefined_mask;
    // Status register undefined mask
    uint32_t fpu_model;
    // Safe memory start (not used)
    uint32_t safe_memory_start;
    // Safe memory end (not used)
    uint32_t safe_memory_end;
    // name of the instruction
    char name[M68K_INST_NAME_SIZE + 1];

} M68KMenemonicData;

// Context for testing one instruction type
typedef struct M68KInstructionTesterContext {
	// Meta data loaded and setup from the header
    M68KMenemonicData metadata;
	// Low memory section
	M68KTesterMemory low_memory;
	// High memory section
	M68KTesterMemory high_memory;
	// Memory for the actual testing code 
	M68KTesterMemory tester_memory;

} M68KInstructionTesterContext;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

typedef struct M68KTesterRunSettings {
	// CPU level to use (0 = 0000, 1 = 010, 2 = 020, 3 = 030, 4 = 040, 5 & 6 = 060)
	uint8_t cpu_level;
	// Verify undefined status registers
	uint8_t check_undefined_sr;
	// continue on error
	uint8_t  continue_on_error;
} M68KTesterRunSettings;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

typedef struct MK68LoadResult {
    M68KInstructionTesterContext* context;
    const char* error;
} MK68LoadResult;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static char* get_error_string(const char* fmt, ...) {
    char output[1024];

    va_list arg_ptr;
    va_start(arg_ptr, fmt);
    vsprintf(output, fmt, arg_ptr);
    va_end(arg_ptr);

    size_t len = strlen(output);
    void* string_mem = malloc(len);

    if (!string_mem) {
        printf("Failed to alloc memory at %s:(%d)", __FILE__, __LINE__);
        exit(1);
    }

    memcpy(string_mem, output, len + 1);
    return (char*)string_mem;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void read_data(void* target, FILE* file, size_t len, const char* filename) {
    size_t read_size = fread(target, 1, len, file);

    if (read_size != len) {
        printf("FATAL: Failed to read from file %s, exiting", filename);
        exit(1);
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

uint32_t read_u32(FILE* file, const char* filename) {
    uint32_t data;
    read_data((void*)&data, file, sizeof(data), filename);

    // endian swap if not m68k
#ifndef M68K
    data = ((((data) & 0xff000000) >> 24)|
           (((data) & 0x00ff0000) >>  8) |
           (((data) & 0x0000ff00) <<  8) |
           (((data) & 0x000000ff) << 24));
#endif
    return data;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static void join_path(char* dest, const char* path, const char* file, int len) {
	size_t path_len = strlen(path);

	if (len_path > 0) {
		if (path[len_path - 1] == '/' || path[len_path - 1] == '\\') {
			sprintf_s(dest, "%s%s", path, file, len);
		} else {
			sprintf_s(dest, "%s/%s", path, file, len);
		}
	} else {
		strncpy_s(dest, file);
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void* malloc_zero(size_t size) {
    void* data = malloc(size);

    if (!data) {
        printf("Failed to alloc memory at %s:(%d)", __FILE__, __LINE__);
        exit(1);
    }

    memset(data, 0, size);
    return data;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static uint8_t* load_memory_file(const char* path, const char* file) {
	char fname[4096];
	join_path(fname, path, file, sizeof(fname));

	FILE *f = fopen(fname, "rb");
	if (!f) {
		return NULL;
	}

	fseek(f, 0, SEEK_END);
	size_t size = ftell(f);
	fseek(f, 0, SEEK_SET);

	void* memory = malloc(size);

	if (!memory) {
        printf("Failed to alloc memory at %s:(%d)", __FILE__, __LINE__);
        exit(1);
	}

	size_t read_bytes = fread(memory, 1, size, f);
	fclose(f);

	if (read_bytes != size) {
		printf("FATAL: Failed read full file %s (wanted %d bytes but got %d)\n", fname, size, read_bytes);
		exit(1);
	}

	return (uint8_t*)memory;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void M68KCpuTester_debug_print(const M68KInstructionTesterContext* context) {
    assert(context);
    const M68KMenemonicData* metadata = &context->metadata;

    printf("---------------------------------------------------------------------------\n");
    printf("%s\n\n", metadata->name);
    printf("  Data version    %08d\n", metadata->version);
    printf("  Start time id   %08x\n\n", metadata->start_time_id);
    printf("  High mem rom  0x%08x\n", metadata->high_mem_rom);
    printf("  Low mem rom   0x%08x\n\n", metadata->low_mem_rom);
    printf("  Safe memory start  0x%08x\n", metadata->safe_memory_start);
    printf("  Safe memory end    0x%08x\n", metadata->safe_memory_end);
    printf("  Safe memory size     %08x\n\n", metadata->safe_memory_end - metadata->safe_memory_start);
    printf("  Test memory start    0x%08x\n", metadata->test_memory_address);
    printf("  Test memory end      0x%08x\n", metadata->test_memory_end);
    printf("  Test memory size       %8d\n\n", metadata->test_memory_end - metadata->test_memory_address);
    printf("  Test low memory start  0x%08x\n", metadata->test_low_memory_start);
    printf("  Test low memory end    0x%08x\n", metadata->test_low_memory_end);
    printf("  Test low memory size     %8d\n\n", metadata->test_low_memory_end - metadata->test_low_memory_start);
    printf("  Test high memory start  0x%08x\n", metadata->test_high_memory_start);
    printf("  Test high memory end    0x%08x\n", metadata->test_high_memory_end);
    printf("  Test high memory size     %8d\n\n", metadata->test_high_memory_end - metadata->test_high_memory_start);
    printf("  CPU Level               0x%08x\n", metadata->cpu_level);
    printf("  Interrupt mask          0x%08x\n", metadata->interrupt_mask);
    printf("  Addressing mask Level   0x%08x\n", metadata->addressing_mask);
    printf("  SR undefined mask Level 0x%08x\n", metadata->sr_undefined_mask);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

MK68LoadResult M68KCpuTester_load_opcode(int selected_cpu_level, const char* opcode, const char* path) {
    MK68LoadResult load_result = { 0 };
    char full_path[4096] = { 0 };
    char filename[4096] = { 0 };
    uint8_t data[4] = { 0 };
    int size = 0;
    uint32_t v = 0;
    int filecnt = 1;
    uint32_t start_time_id;
    int lvl = 0;

	join_path(full_path, path, opcode, sizeof(full_path));
	sprintf_s(filename, "%s/0000.dat", full_path, sizeof(filename));

    FILE* f = fopen(filename, "rb");

    if (!f) {
        load_result.error = get_error_string("Couldn't open '%s'\n", filename);
        return load_result;
    }

    uint32_t data_version = read_u32(f, filename);

    if (data_version != M68K_DATA_VERSION) {
        fclose(f);
        load_result.error = get_error_string("Data file %s doesn't match expected version (%d) but was %d",
                                             filename, M68K_DATA_VERSION, v);
        return load_result;
    }

    M68KInstructionTesterContext* context = malloc_zero(sizeof(M68KInstructionTesterContext));
    M68KMenemonicData* metadata = &context->metadata;

    // setup all the data

    metadata->version = data_version;
    metadata->start_time_id = read_u32(f, filename);
    uint32_t hlmem_rom = read_u32(f, filename);

    context->test_memory.address = read_u32(f, filename);
    context->test_memory.size = read_u32(f, filename);
    context->test_memory.end = context->test_memory.address + context->test_memory.size;

    metadata->opcode_memory_address = read_u32(f, filename) + metadata->test_memory.address;

    uint32_t flags = read_u32(f, filename);
    metadata->fpu_model = read_u32(f, filename);

    context->low_memory.start = read_u32(f, filename);
    context->low_memory.end = read_u32(f, filename);
    context->low_memory.size = context->low_memory.end - context->low_memory.start;

    context->high_memory.start = read_u32(f, filename);
    context->high_memory.end = read_u32(f, filename);
    context->high_memory.size = context->high_memory.end - context->high_memory.start;

    metadata->safe_memory_start = read_u32(f, filename);
    metadata->safe_memory_end = read_u32(f, filename);

    fseek(f, 8, SEEK_CUR);  // skip unsed
    read_data(metadata->name, f, M68K_INST_NAME_SIZE, filename);

    // Patch up the data after the initial loading is complete

    metadata->high_mem_rom = (uint16_t)(hlmem_rom >> 16);
    metadata->low_mem_rom = (uint16_t)(hlmem_rom & 0xffff);

    metadata->cpu_level = (flags >> 16) & 15;
    metadata->interrupt_mask = (flags >> 20) & 7;
    metadata->addressing_mask = (flags & 0x80000000) ? 0xffffffff : 0x00ffffff;
    metadata->flag_mode = (flags >> 30) & 1;
    metadata->sr_undefined_mask = flags & 0xffff;

    const int lvl = metadata->cpu_levels;
	int lvl2 = selected_cpu_level;
	if (lvl2 == 5 && lvl2 != lvl)
		lvl2 = 4;

	if (lev != lvl2) {
		load_result.error = get_error_string("Mismatched CPU model: %lu <> %lu\n",
			68000 + 10 * (cpu_lvl < 5 ? cpu_lvl : 6), 68000 + (lvl < 5 ? lvl : 6) * 10);
		return load_result;
	}

	if (!options->check_undefined_sr) {
		metadata->sr_undefined_mask = ~metadat->sr_undefined_mask;
	} else {
		metadata->sr_undefined_mask = 0xffff;
	}

	if (metadata->test_low_memory_start != 0xffffffff)
		context->low_memory_offset = metadata->test_low_memory_start;
	if (metadata->test_high_memory_start != 0xffffffff)
		context->high_memory_offset = metadata->test_high_memory_start & 0x7fff;

	// Load the memory files

	if (!load_memory_file(&context->low_memory, path, "lmem.dat")) {
        load_result.error = get_error_string("Unable to load lmem.dat in path %s", path);
        return load_result;
	}

	if (!load_memory_file(&context->high_memory, path, "hmem.dat")) {
        load_result.error = get_error_string("Unable to load hmem.dat in path %s", path);
        return load_result;
	}

	if (!load_memory_file(&context->test_memory, path, "tmem.dat")) {
        load_result.error = get_error_string("Unable to load tmem.dat in path %s", path);
        return load_result;
	}

	context->opcode_memory = context->test_memory.memory + 
		(context->opcode_memory_address - context->test_memory.buffer);

    load_result.context = context;
    return load_result;
}

int main() {
    MK68LoadResult load = M68KCpuTester_load_opcode("MOVE.W", "data/68000/");

    if (load.error) {
        printf("%s:%d failed to load data: %s\n", __FILE__, __LINE__, load.error);
        return 1;
    }

    M68KCpuTester_debug_print(load.context);

    return 0;
}
