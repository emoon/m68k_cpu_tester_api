//
// Notice that this isn't done yet and currently doesn't compile
//

#include <assert.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

//#include "../cputest_defines.h"
#define DATA_VERSION 6

#define CT_FPREG 0
#define CT_DREG 0
#define CT_AREG 8
#define CT_SSP 16
#define CT_MSP 17
#define CT_SR 18
#define CT_PC 19
#define CT_FPIAR 20
#define CT_FPSR 21
#define CT_FPCR 22
#define CT_SRCADDR 28
#define CT_DSTADDR 29
#define CT_MEMWRITE 30
#define CT_MEMWRITES 31
#define CT_DATA_MASK 31
#define CT_EXCEPTION_MASK 63

#define CT_SIZE_BYTE (0 << 5)
#define CT_SIZE_WORD (1 << 5)
#define CT_SIZE_LONG (2 << 5)
#define CT_SIZE_FPU (3 << 5) // CT_DREG -> CT_FPREG
#define CT_SIZE_MASK (3 << 5)

// if MEMWRITE or PC
#define CT_RELATIVE_START_WORD (0 << 5) // word
#define CT_ABSOLUTE_WORD (1 << 5)
#define CT_ABSOLUTE_LONG (2 << 5)
// if MEMWRITES
#define CT_PC_BYTES (3 << 5)
// if PC
#define CT_RELATIVE_START_BYTE (3 << 5)

#define CT_END 0x80
#define CT_END_FINISH 0xff
#define CT_END_INIT (0x80 | 0x40)
#define CT_END_SKIP (0x80 | 0x40 | 0x01)
#define CT_SKIP_REGS (0x80 | 0x40 | 0x02)
#define CT_EMPTY CT_END_INIT

#define M68K_INST_NAME_SIZE 16

typedef uint32_t u32;
typedef uint16_t u16;

// 80-bit register type
typedef struct M68KFpuReg {
    uint16_t exp;
    uint16_t dummy;
    uint32_t m[2];
} M68KFpuReg;

// Holds all the registers
struct M68KRegisters {
    uint32_t regs[16];
    uint32_t ssp;
    uint32_t msp;
    uint32_t pc;
    uint32_t sr;
    uint32_t exc;
    uint32_t excframe;
    M68KFpuReg fpuregs[8];
    uint32_t fpiar, fpcr, fpsr;
    uint32_t srcaddr, dstaddr;
} M68KRegisters;

typedef struct M68KTesterMemory {
    // original memory loaded to (name to match original code)
    uint8_t* temp;
    // memory in use
    uint8_t* buffer;
    // Backup memory of memory ptr, used for restoring the memory
    uint8_t* backup;
    // Memory start location in 32-bit address space
    uint32_t offset;
    // Memory start location in 32-bit address space
    uint32_t start;
    // Memory end location in 32-bit address space
    uint32_t end;
    // Size of test memory
    uint32_t size;
} M68KTesterMemory;

// Context for testing one instruction type
typedef struct M68KTesterContext {
    // Points to the op-codes currently being processed
    uint8_t* opcode_memory;
    // the files generated by cputestgen has a version written in it so that needs to match with the loader code
    uint32_t version;
    // Hold time stamp of the written file. This is checked so the other data file matches this and nothing is out of
    // data
    uint32_t start_time_id;
    // Start address for high-mem rom?
    uint16_t high_mem_rom;
    // Start address for low-mem rom?
    uint16_t low_mem_rom;
    // Start of opcode memory
    uint32_t opcode_memory_address;
    // CPU type to use
    uint32_t cpu_level;
    // Interrupts to test
    uint32_t interrupt_mask;
    // Addressing to test
    uint32_t addressing_mask;
    // Flag mode
    uint32_t flag_mode;
    // Status register undefined mask
    uint32_t sr_undefined_mask;
    // Status register undefined mask
    uint32_t fpu_model;
    // Safe memory start (not used)
    uint32_t safe_memory_start;
    // Safe memory end (not used)
    uint32_t safe_memory_end;
    // Low memory section
    M68KTesterMemory low_memory;
    // High memory section
    M68KTesterMemory high_memory;
    // Memory for the actual testing code
    M68KTesterMemory test_memory;
    // name of the instruction
    char name[M68K_INST_NAME_SIZE + 1];
    // Mutable stuff that changes when running the tests
    int testcnt;
	uint32_t error_vectors[12];
	uint32_t vbr[256];
	uint32_t* error_vector;
	uint8_t test_active;

} M68KTesterContext;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

typedef struct M68KTesterRunSettings {
    // CPU level to use (0 = 0000, 1 = 010, 2 = 020, 3 = 030, 4 = 040, 5 & 6 = 060)
    uint8_t cpu_level;
    // Verify undefined status registers
    uint8_t check_undefined_sr;
    // continue on error
    uint8_t continue_on_error;
} M68KTesterRunSettings;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

typedef struct MK68LoadResult {
    M68KTesterContext* context;
    const char* error;
} MK68LoadResult;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static char* get_error_string(const char* fmt, ...) {
    char output[1024];

    va_list arg_ptr;
    va_start(arg_ptr, fmt);
    vsprintf(output, fmt, arg_ptr);
    va_end(arg_ptr);

    size_t len = strlen(output);
    void* string_mem = malloc(len);

    if (!string_mem) {
        printf("Failed to alloc memory at %s:(%d)", __FILE__, __LINE__);
        exit(1);
    }

    memcpy(string_mem, output, len + 1);
    return (char*)string_mem;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void read_data(void* target, FILE* file, size_t len, const char* filename) {
    size_t read_size = fread(target, 1, len, file);

    if (read_size != len) {
        printf("FATAL: Failed to read from file %s, exiting", filename);
        exit(1);
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

uint32_t read_u32(FILE* file, const char* filename) {
    uint32_t data;
    read_data((void*)&data, file, sizeof(data), filename);

    // endian swap if not m68k
#ifndef M68K
    data = ((((data)&0xff000000) >> 24) | (((data)&0x00ff0000) >> 8) | (((data)&0x0000ff00) << 8) |
            (((data)&0x000000ff) << 24));
#endif
    return data;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static void join_path(char* dest, const char* path, const char* file, int len) {
    (void)len;
    size_t path_len = strlen(path);

    if (path_len > 0) {
        if (path[path_len - 1] == '/' || path[path_len - 1] == '\\') {
            sprintf(dest, "%s%s", path, file);
        } else {
            sprintf(dest, "%s/%s", path, file);
        }
    } else {
        strncpy(dest, file, len);
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void* malloc_zero(size_t size) {
    void* data = malloc(size);

    if (!data) {
        printf("Failed to alloc memory at %s:(%d)", __FILE__, __LINE__);
        exit(1);
    }

    memset(data, 0, size);
    return data;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static bool load_memory_file(M68KTesterMemory* memory, const char* path, const char* file) {
    char fname[4096];
    join_path(fname, path, file, sizeof(fname));

    FILE* f = fopen(fname, "rb");
    if (!f) {
        return false;
    }

    fseek(f, 0, SEEK_END);
    size_t size = ftell(f);
    fseek(f, 0, SEEK_SET);

    void* buffer = (uint8_t*)malloc(size);
    void* backup = (uint8_t*)malloc(size);
    void* temp = (uint8_t*)malloc(size);

    if (!memory || !backup || !temp) {
        printf("Failed to alloc memory at %s:(%d)", __FILE__, __LINE__);
        return false;
    }

    size_t read_bytes = fread(temp, 1, size, f);
    fclose(f);

    if (read_bytes != size) {
        printf("FATAL: Failed read full file %s (wanted %ld bytes but got %ld)\n", fname, size, read_bytes);
        return false;
    }

    memory->buffer = buffer;
    memory->backup = backup;
    memory->backup = temp;

    memcpy(buffer, temp, size);
    memcpy(backup, temp, size);

    return true;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static void print_memory(const M68KTesterMemory* memory, const char* name) {
    printf("  %s start  0x%08x\n", name, memory->start);
    printf("  %s end    0x%08x\n", name, memory->end);
    printf("  %s size   0x%08d\n", name, memory->size);
    printf("  %s buffer %p\n", name, memory->buffer);
    printf("  %s backup %p\n\n", name, memory->backup);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void M68KCpuTester_debug_print(const M68KTesterContext* context) {
    assert(context);

    printf("---------------------------------------------------------------------------\n");
    printf("%s\n\n", context->name);
    printf("  Data version    %08d\n", context->version);
    printf("  Start time id   %08x\n\n", context->start_time_id);
    printf("  High mem rom  0x%08x\n", context->high_mem_rom);
    printf("  Low mem rom   0x%08x\n\n", context->low_mem_rom);
    printf("  CPU Level               0x%08x\n", context->cpu_level);
    printf("  Interrupt mask          0x%08x\n", context->interrupt_mask);
    printf("  Addressing mask Level   0x%08x\n", context->addressing_mask);
    printf("  SR undefined mask Level 0x%08x\n\n", context->sr_undefined_mask);
    printf("  Opcode memory address   0x%08x\n", context->opcode_memory_address);
    printf("  Opcode memory (native)  %p\n\n", context->opcode_memory);

    print_memory(&context->low_memory, "low");
    print_memory(&context->high_memory, "high");
    print_memory(&context->test_memory, "tester");
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static void endinfo(M68KTesterContext* context) {
    printf("Last test: %d\n", context->testcnt);
    uint8_t* p = context->opcode_memory;
    for (int i = 0; i < 32 * 2; i += 2) {
        uint16_t v = (p[i] << 8) | (p[i + 1]);
        if (v == 0x4afc && i > 0) break;
        printf(" %04x", v);
    }
    printf("\n");
}

static void safe_memcpy(uint8_t* d, uint8_t* s, int size) {
    memcpy(d, s, size);
}

static uint32_t s_vbr_zero[256];

// static int test_active;
// static uint32_t enable_data;
// static uint32_t error_vectors[12];

// if exception happens outside of test code, jump to
// infinite loop and flash colors.
static void reset_error_vectors(M68KTesterContext* context) {
    uint32_t* p;
    if (context->cpu_level == 0) {
        p = s_vbr_zero;
    } else {
        p = context->vbr;
    }
    for (int i = 2; i < 4; i++) {
        p[i] = context->error_vectors[i - 2];
    }
}

/*
static void set_error_vectors(M68KTesterContext* context) {
    uint32_t* p;
    if (context->cpu_level == 0) {
        p = s_vbr_zero;
    } else {
        p = context->vbr;
    }
    for (int i = 2; i < 4; i++) {
        p[i] = (uint32_t)&context->error_vector;
    }
}
*/

static void start_test(M68KTesterContext* context) {
    if (context->test_active)
    	return;

    context->test_active = 1;

	uint8_t* low_memory_back = context->low_memory.backup;
	uint8_t* low_memory_temp = context->low_memory.temp;
	uint8_t* low_memory = context->low_memory.buffer;
    uint32_t low_memory_offset = context->low_memory.offset;
	uint32_t low_memory_size = context->low_memory.size;

	uint8_t* high_memory = context->high_memory.buffer;
	uint8_t* high_memory_temp = context->high_memory.temp;
    uint8_t* high_memory_back = context->high_memory.backup;
    uint32_t high_memory_offset = context->high_memory.offset;
	uint32_t high_memory_size = context->high_memory.size;

	safe_memcpy(low_memory_back + low_memory_offset, low_memory + low_memory_offset, low_memory_size - low_memory_offset);

	// always copy exception vectors if 68000
	if (context->cpu_level == 0 && low_memory_offset > 0x08)
		safe_memcpy(low_memory_back + 8, low_memory + 8, (192 - 2) * 4);

	if (!context->high_mem_rom)
		safe_memcpy(high_memory_back, high_memory + high_memory_offset, high_memory_size - high_memory_offset);

	safe_memcpy(low_memory + low_memory_offset, low_memory_temp + low_memory_offset, low_memory_size - low_memory_offset);

	if (context->cpu_level == 0 && low_memory_offset > 0x08)
		safe_memcpy(low_memory + 8, low_memory_temp + 8, (192 - 2) * 4);

	if (!context->high_mem_rom)
		safe_memcpy(high_memory + high_memory_offset, high_memory_temp, high_memory_size - high_memory_offset);

	/*
    if (cpu_level == 0) {
        uint32_t* p = (uint32_t*)vbr_zero;
        for (int i = 2; i < 12; i++) {
            p[i] = (uint32_t)(((uint32_t)&exceptiontable000) + (i - 2) * 2);
            if (i < 12 + 2) {
                error_vectors[i - 2] = p[i];
            }
        }
        for (int i = 32; i < 48; i++) {
            p[i] = (uint32_t)(((uint32_t)&exceptiontable000) + (i - 2) * 2);
        }
    } else {
        oldvbr = setvbr((uint32_t)vbr);
        for (int i = 2; i < 48; i++) {
            if (fpu_model) {
                vbr[i] = (uint32_t)(((uint32_t)&exceptiontablefpu) + (i - 2) * 2);
            } else if (cpu_level == 1) {
                vbr[i] = (uint32_t)(((uint32_t)&exceptiontable010) + (i - 2) * 2);
            } else {
                vbr[i] = (uint32_t)(((uint32_t)&exceptiontable020) + (i - 2) * 2);
            }
            if (i >= 2 && i < 12) {
                error_vectors[i - 2] = vbr[i];
            }
        }
    }
    setcpu(cpu_level, cpustatearraynew, cpustatearraystore);
    */
}

static void end_test(M68KTesterContext* context) {
    if (!context->test_active)
    	return;

    context->test_active = 0;

	uint8_t* low_memory_back = context->low_memory.backup;
	//uint8_t* low_memory_temp = context->low_memory.temp;
	uint8_t* low_memory = context->low_memory.buffer;
    uint32_t low_memory_offset = context->low_memory.offset;
	uint32_t low_memory_size = context->low_memory.size;

	uint8_t* high_memory = context->high_memory.buffer;
	//uint8_t* high_memory_temp = context->high_memory.temp;
    uint8_t* high_memory_back = context->high_memory.backup;
    uint32_t high_memory_offset = context->high_memory.offset;
	uint32_t high_memory_size = context->high_memory.size;

    safe_memcpy(low_memory + low_memory_offset, low_memory_back + low_memory_offset,
                low_memory_size - low_memory_offset);

    if (context->cpu_level == 0 && low_memory_offset > 0x08)
    	safe_memcpy(low_memory + 8, low_memory_back + 8, (192 - 2) * 4);

    if (!context->high_mem_rom)
        safe_memcpy(high_memory + high_memory_offset, high_memory_back, high_memory_size - high_memory_offset);

    if (context->cpu_level > 0) {
        //setvbr(oldvbr);
    }

    // setcpu(cpu_level, cpustatearraystore, NULL);
    //touser(enable_data);
}

static void pl(uint8_t* p, uint32_t v) {
    p[0] = v >> 24;
    p[1] = v >> 16;
    p[2] = v >> 8;
    p[3] = v >> 0;
}
static void pw(uint8_t* p, uint32_t v) {
    p[0] = v >> 8;
    p[1] = v >> 0;
}

static uint32_t gl(uint8_t* p) { return (p[0] << 24) | (p[1] << 16) | (p[2] << 8) | (p[3] << 0); }

static uint16_t gw(uint8_t* p) { return (p[0] << 8) | (p[1] << 0); }

static uint8_t* restore_fpvalue(M68KTesterContext* context, uint8_t* p, M68KFpuReg* fp) {
    uint8_t v = *p++;
    if ((v & CT_SIZE_MASK) != CT_SIZE_FPU) {
        end_test(context);
        printf("Expected CT_SIZE_FPU, got %02x\n", v);
        endinfo(context);
        exit(0);
    }
    fp->exp = gw(p);
    p += 2;
    fp->m[0] = gl(p);
    p += 4;
    fp->m[1] = gl(p);
    p += 4;
    fp->dummy = 0;
    return p;
}

static uint8_t* restore_value(M68KTesterContext* context, uint8_t* p, uint32_t* vp, int* sizep) {
    uint32_t val = *vp;
    uint8_t v = *p++;
    switch (v & CT_SIZE_MASK) {
        case CT_SIZE_BYTE:
            val &= 0xffffff00;
            val |= *p++;
            *sizep = 0;
            break;
        case CT_SIZE_WORD:
            val &= 0xffff0000;
            val |= (*p++) << 8;
            val |= *p++;
            *sizep = 1;
            break;
        case CT_SIZE_LONG:
            val = (*p++) << 24;
            val |= (*p++) << 16;
            val |= (*p++) << 8;
            val |= *p++;
            *sizep = 2;
            break;
        case CT_SIZE_FPU:
            end_test(context);
            printf("Unexpected CT_SIZE_FPU\n");
            endinfo(context);
            exit(0);
            break;
    }
    *vp = val;
    return p;
}

static uint8_t* restore_rel(M68KTesterContext* context, uint8_t* p, uint32_t* vp, int nocheck) {
    uint32_t v = *vp;
    switch ((*p++) & CT_SIZE_MASK) {
        case CT_RELATIVE_START_BYTE: {
            uint8_t val;
            val = *p++;
            v += (int8_t)val;
            break;
        }
        case CT_RELATIVE_START_WORD: {
            uint16_t val;
            val = (*p++) << 8;
            val |= *p++;
            v += (int16_t)val;
            break;
        }
        case CT_ABSOLUTE_WORD: {
            uint16_t val;
            val = (*p++) << 8;
            val |= *p++;
            v = (int32_t)(int16_t)val;
            break;
        }
        case CT_ABSOLUTE_LONG: {
            uint32_t val;
            val = (*p++) << 24;
            val |= (*p++) << 16;
            val |= (*p++) << 8;
            val |= *p++;
            v = val;
            /*
            if (!nocheck) {
                if ((val & context->addressing_mask) < low_memory_size) {
                    ;  // low memory
                } else if ((val & ~addressing_mask) == ~addressing_mask && val >= 0xfff80000) {
                    ;  // high memory
                } else if ((val & addressing_mask) < test_memory_addr ||
                           (val & addressing_mask) >= test_memory_addr + test_memory_size) {
                    end_test(context);
                    printf("restore_rel CT_ABSOLUTE_LONG outside of test memory! %08x\n", v);
                    endinfo(context);
                    exit(0);
                }
            }
            */
            break;
        }
    }
    *vp = v;
    return p;
}

static uint8_t* restore_rel_ordered(M68KTesterContext* context, uint8_t* p, uint32_t* vp) {
    if (*p == CT_EMPTY)
    	return p + 1;
    return restore_rel(context, p, vp, 1);
}

static void validate_mode(M68KTesterContext* context, uint8_t mode, uint8_t v) {
    if ((mode & CT_DATA_MASK) != v) {
        end_test(context);
        printf("CT_MEMWRITE expected but got %02X\n", mode);
        endinfo(context);
        exit(0);
    }
}

static uint8_t* get_memory_addr(M68KTesterContext* context, uint8_t* p, uint8_t** addrp) {
	uint8_t* high_memory = context->high_memory.buffer;
	uint8_t* low_memory = context->low_memory.buffer;
	uint32_t low_memory_size = context->low_memory.size;
	uint32_t test_memory_addr = context->test_memory.start;
	uint32_t test_memory_size = context->test_memory.size;

    uint8_t v = *p++;
    switch (v & CT_SIZE_MASK) {
        case CT_ABSOLUTE_WORD: {
            uint16_t val;
            val = (*p++) << 8;
            val |= *p++;
            uint8_t* addr;
            int16_t offset = (int16_t)val;
            if (offset < 0) {
                addr = high_memory + 32768 + offset;
            } else {
                addr = low_memory + offset;
            }
            validate_mode(context, p[0], CT_MEMWRITE);
            *addrp = addr;
            return p;
        }
        case CT_ABSOLUTE_LONG: {
            uint32_t val;
            val = (*p++) << 24;
            val |= (*p++) << 16;
            val |= (*p++) << 8;
            val |= *p++;
            if (val < low_memory_size) {
            	// TODO: Validate
                uint8_t* addr = low_memory + (val - context->low_memory.start);
                validate_mode(context, p[0], CT_MEMWRITE);
                *addrp = addr;
                return p;
            } else if (val >= test_memory_addr && val < test_memory_addr + test_memory_size) {
            	// TODO: Validate
                uint8_t* addr = context->test_memory.buffer + (val - test_memory_addr);
                validate_mode(context, p[0], CT_MEMWRITE);
                *addrp = addr;
                return p;
            } else {
                end_test(context);
                printf("get_memory_addr CT_ABSOLUTE_LONG outside of test memory! %08x\n", val);
                endinfo(context);
                exit(0);
            }
        }
        case CT_RELATIVE_START_WORD: {
            uint16_t val;
            val = (*p++) << 8;
            val |= *p++;
            int16_t offset = (int16_t)val;
            uint8_t* addr = context->opcode_memory + offset;
            validate_mode(context, p[0], CT_MEMWRITE);
            *addrp = addr;
            return p;
        } break;

        default:
            end_test(context);
            printf("get_memory_addr unknown size %02x\n", v);
            endinfo(context);
            exit(0);
    }
    return NULL;
}

static void tomem(M68KTester* context, uint8_t* p, uint32_t v, uint32_t oldv, int size, int storedata) {
    if (storedata) {
        struct accesshistory* ah = &ahist[ahcnt++];
        ah->oldval = oldv;
        ah->val = v;
        ah->size = size;
        ah->addr = p;
    }
    switch (size) {
        case 0:
            p[0] = (uint8_t)v;
            break;
        case 1:
            p[0] = (uint8_t)(v >> 8);
            p[1] = (uint8_t)(v >> 0);
            break;
        case 2:
            p[0] = (uint8_t)(v >> 24);
            p[1] = (uint8_t)(v >> 16);
            p[2] = (uint8_t)(v >> 8);
            p[3] = (uint8_t)(v >> 0);
            break;
    }
}

static void restoreahist(void) {
    if (!ahcnt) return;
    for (int i = ahcnt - 1; i >= 0; i--) {
        struct accesshistory* ah = &ahist[i];
        tomem(ah->addr, ah->oldval, 0, ah->size, 0);
    }
    ahcnt = 0;
}

static uint8_t* restore_memory(uint8_t* p, int storedata) {
    uint8_t v = *p;
    switch (v & CT_SIZE_MASK) {
        case CT_ABSOLUTE_WORD: {
            uint8_t* addr;
            int size;
            p = get_memory_addr(p, &addr);
            uint32_t mv = 0;
            uint32_t oldv = 0;
            p = restore_value(p, &oldv, &size);
            p = restore_value(p, &mv, &size);
            tomem(addr, mv, oldv, size, storedata);
            return p;
        }
        case CT_ABSOLUTE_LONG: {
            uint8_t* addr;
            int size;
            p = get_memory_addr(p, &addr);
            uint32_t mv = 0;
            uint32_t oldv = 0;
            p = restore_value(p, &oldv, &size);
            p = restore_value(p, &mv, &size);
            tomem(addr, mv, oldv, size, storedata);
            return p;
        }
    }
    if ((v & CT_DATA_MASK) == CT_MEMWRITES) {
        switch (v & CT_SIZE_MASK) {
            case CT_PC_BYTES: {
                p++;
                uint8_t* addr = opcode_memory;
                uint8_t v = *p++;
                addr += v >> 5;
                v &= 31;
                if (v == 0) v = 32;
                memcpy(addr, p, v);
                p += v;
                break;
            }
            default:
                end_test();
                printf("Unknown restore_memory type!?\n");
                endinfo();
                exit(0);
                break;
        }
    } else {
        switch (v & CT_SIZE_MASK) {
            case CT_RELATIVE_START_WORD: {
                uint8_t* addr;
                int size;
                p = get_memory_addr(p, &addr);
                uint32_t mv = 0, oldv = 0;
                p = restore_value(p, &oldv, &size);
                p = restore_value(p, &mv, &size);
                tomem(addr, mv, oldv, size, storedata);
                return p;
            }
            default:
                end_test();
                printf("Unknown restore_memory type!?\n");
                endinfo();
                exit(0);
                break;
        }
    }
    return p;
}

static uint8_t* restore_data(uint8_t* p) {
    uint8_t v = *p;
    if (v & CT_END) {
        end_test();
        printf("Unexpected end bit!? offset %ld\n", p - test_data);
        endinfo();
        exit(0);
    }
    int mode = v & CT_DATA_MASK;
    if (mode == CT_SRCADDR) {
        int size;
        p = restore_value(p, &regs.srcaddr, &size);
    } else if (mode == CT_DSTADDR) {
        int size;
        p = restore_value(p, &regs.dstaddr, &size);
    } else if (mode < CT_AREG + 8) {
        int size;
        if ((v & CT_SIZE_MASK) == CT_SIZE_FPU) {
            p = restore_fpvalue(p, &regs.fpuregs[mode]);
        } else {
            p = restore_value(p, &regs.regs[mode], &size);
        }
    } else if (mode == CT_SR) {
        int size;
        p = restore_value(p, &regs.sr, &size);
    } else if (mode == CT_FPIAR) {
        int size;
        p = restore_value(p, &regs.fpiar, &size);
    } else if (mode == CT_FPCR) {
        int size;
        p = restore_value(p, &regs.fpcr, &size);
    } else if (mode == CT_FPSR) {
        int size;
        p = restore_value(p, &regs.fpsr, &size);
    } else if (mode == CT_MEMWRITE) {
        // if memwrite, store old data
        p = restore_memory(p, 1);
    } else if (mode == CT_MEMWRITES) {
        p = restore_memory(p, 0);
    } else {
        end_test();
        printf("Unexpected mode %02x\n", v);
        endinfo();
        exit(0);
    }
    return p;
}

// static uint16_t test_sr, test_ccrignoremask;
// static uint32_t test_fpsr, test_fpcr;

static int is_valid_test_addr(uint32_t a) {
    if ((uint8_t*)a >= safe_memory_start && (uint8_t*)a < safe_memory_end) return 0;
    return (a >= test_low_memory_start && a < test_low_memory_end && test_low_memory_start != 0xffffffff) ||
           (a >= test_high_memory_start && a < test_high_memory_end && test_high_memory_start != 0xffffffff) ||
           (a >= test_memory_addr && a < test_memory_end);
}

static int addr_diff(uint8_t* ap, uint8_t* bp, int size) {
    for (int i = 0; i < size; i++) {
        if (is_valid_test_addr((uint32_t)bp)) {
            if (*ap != *bp) return 1;
        }
        ap++;
        bp++;
    }
    return 0;
}

static void addinfo_bytes(char* name, uint8_t* src, uint32_t address, int offset, int len) {
    sprintf(outbp, "%s %08lx ", name, address);
    address += offset;
    outbp += strlen(outbp);
    int cnt = 0;
    while (len-- > 0) {
        if (offset == 0)
            *outbp++ = '*';
        else if (cnt > 0)
            *outbp++ = '.';
        if ((uint8_t*)address >= safe_memory_start && (uint8_t*)address < safe_memory_end) {
            outbp[0] = '?';
            outbp[1] = '?';
        } else {
            sprintf(outbp, "%02x", src[cnt]);
        }
        outbp += 2;
        offset++;
        address++;
        cnt++;
    }
    *outbp++ = '\n';
}

extern uint16_t disasm_instr(uint16_t*, char*);

/*
static void addinfo(void)
{
        if (infoadded)
                return;
        infoadded = 1;
        if (!dooutput)
                return;
        sprintf(outbp, "%lu:", testcnt);
        outbp += strlen(outbp);

        uint16_t *code;
#ifndef M68K
        uint16_t swapped[16];
        for (int i = 0; i < 16; i++) {
                swapped[i] = (opcode_memory[i * 2 + 0] << 8) | (opcode_memory[i * 2 + 1] << 0);
        }
        code = swapped;
#else
        code = (uint16_t*)opcode_memory;
#endif
        uint8_t *p = opcode_memory;
        int offset = 0;
        int lines = 0;
        while (lines++ < 10) {
                tmpbuffer[0] = 0;
                int v = disasm_instr(code + offset, tmpbuffer);
                for (int i = 0; i < v; i++) {
                        uint16_t v = (p[i * 2 + 0] << 8) | (p[i * 2 + 1]);
                        sprintf(outbp, "%s%04x", i ? " " : (lines == 0 ? "\t\t" : "\t"), v);
                        outbp += strlen(outbp);
                }
                sprintf(outbp, " %s\n", tmpbuffer);
                outbp += strlen(outbp);
                if (v <= 0)
                        break;
                while (v > 0) {
                        offset++;
                        p += 2;
                        if (code[offset] == 0x4afc) {
                                v = -1;
                                break;
                        }
                        v--;
                }
                if (v < 0)
                        break;
        }
        *outbp = 0;
        if (code[0] == 0x4e73 || code[0] == 0x4e74 || code[0] == 0x4e75) {
                addinfo_bytes("P", stackaddr, stackaddr_ptr, -SIZE_STORED_ADDRESS_OFFSET, SIZE_STORED_ADDRESS);
                addinfo_bytes(" ", (uint8_t *)stackaddr_ptr - SIZE_STORED_ADDRESS_OFFSET, stackaddr_ptr,
-SIZE_STORED_ADDRESS_OFFSET, SIZE_STORED_ADDRESS);
        }
        if (regs.srcaddr != 0xffffffff) {
                uint8_t *a = srcaddr;
                uint8_t *b = (uint8_t *)regs.srcaddr - SIZE_STORED_ADDRESS_OFFSET;
                addinfo_bytes("S", a, regs.srcaddr, -SIZE_STORED_ADDRESS_OFFSET, SIZE_STORED_ADDRESS);
                if (addr_diff(a, b, SIZE_STORED_ADDRESS)) {
                        addinfo_bytes(" ", b, regs.srcaddr, -SIZE_STORED_ADDRESS_OFFSET, SIZE_STORED_ADDRESS);
                }
        }
        if (regs.dstaddr != 0xffffffff) {
                uint8_t *a = dstaddr;
                uint8_t *b = (uint8_t*)regs.dstaddr - SIZE_STORED_ADDRESS_OFFSET;
                addinfo_bytes("D", a, regs.dstaddr, -SIZE_STORED_ADDRESS_OFFSET, SIZE_STORED_ADDRESS);
                if (addr_diff(a, b, SIZE_STORED_ADDRESS)) {
                        addinfo_bytes(" ", b, regs.dstaddr, -SIZE_STORED_ADDRESS_OFFSET, SIZE_STORED_ADDRESS);
                }
        }
}
*/

void addinfo() {}

struct srbit {
    char* name;
    int bit;
};
static const struct srbit srbits[] = {{"T1", 15}, {"T0", 14}, {"S", 13}, {"M", 12}, {"X", 4},
                                      {"N", 3},   {"Z", 2},   {"V", 1},  {"C", 0},  {NULL, 0}};

static void out_regs(struct registers* r, int before) {
    if (before) {
        for (int i = 0; i < 16; i++) {
            if (i > 0 && (i % 4) == 0) {
                strcat(outbp, "\n");
            } else if ((i % 8) != 0) {
                strcat(outbp, " ");
            }
            outbp += strlen(outbp);
            sprintf(outbp, "%c%d:%c%08lx", i < 8 ? 'D' : 'A', i & 7,
                    test_regs.regs[i] != last_registers.regs[i] ? '*' : ' ', r->regs[i]);
            outbp += strlen(outbp);
        }
        *outbp++ = '\n';
    } else {
        // output only lines that have at least one modified register to save screen space
        for (int i = 0; i < 4; i++) {
            int diff = 0;
            for (int j = 0; j < 4; j++) {
                int idx = i * 4 + j;
                if (test_regs.regs[idx] != regs.regs[idx]) {
                    diff = 1;
                }
            }
            if (diff) {
                for (int j = 0; j < 4; j++) {
                    int idx = i * 4 + j;
                    if (j > 0) *outbp++ = ' ';
                    sprintf(outbp, "%c%d:%c%08lx", idx < 8 ? 'D' : 'A', idx & 7,
                            test_regs.regs[idx] != last_registers.regs[idx] ? '*' : ' ', test_regs.regs[idx]);
                    outbp += strlen(outbp);
                }
                *outbp++ = '\n';
            }
        }
    }
    sprintf(outbp, "SR:%c%04x   PC: %08lx ISP: %08lx", test_sr != last_registers.sr ? '*' : ' ',
            before ? test_sr : test_regs.sr, r->pc, r->ssp);
    outbp += strlen(outbp);
    if (cpu_level >= 2 && cpu_level <= 4) {
        sprintf(outbp, " MSP: %08lx", r->msp);
        outbp += strlen(outbp);
    }
    *outbp++ = '\n';

    if (before >= 0) {
        uint16_t s = before ? test_sr : test_regs.sr;  // current value
        uint16_t s1 = regs.sr;                         // original value
        uint16_t s2 = test_regs.sr;                    // test result value
        uint16_t s3 = last_registers.sr;               // expected result value
        for (int i = 0; srbits[i].name; i++) {
            if (i > 0) *outbp++ = ' ';
            uint16_t mask = 1 << srbits[i].bit;
            sprintf(outbp, "%s%c%d", srbits[i].name,
                    (s2 & mask) != (s3 & mask) ? '!' : ((s1 & mask) != (s2 & mask) ? '*' : '='), (s & mask) != 0);
            outbp += strlen(outbp);
        }
        *outbp++ = '\n';
    }

    if (!fpu_model) return;

    for (int i = 0; i < 8; i++) {
        if ((i % 2) == 0) {
            strcat(outbp, "\n");
        } else if ((i % 4) != 0) {
            strcat(outbp, " ");
        }
        outbp += strlen(outbp);
        struct fpureg* f = &r->fpuregs[i];
        void* f1 = &regs.fpuregs[i];
        void* f2 = &test_regs.fpuregs[i];
        sprintf(outbp, "FP%d:%c%04x-%08lx%08lx %f", i, memcmp(f1, f2, sizeof(struct fpureg)) ? '*' : ' ', f->exp,
                f->m[0], f->m[1], *((long double*)f));
        outbp += strlen(outbp);
    }
    sprintf(outbp, "\nFPSR:%c%08lx FPCR:%c%08lx FPIAR:%c%08lx\n", test_fpsr != test_regs.fpsr ? '*' : ' ',
            before ? test_fpsr : r->fpsr, test_fpcr != test_regs.fpcr ? '*' : ' ', before ? test_fpcr : r->fpcr,
            regs.fpiar != test_regs.fpiar ? '*' : ' ', r->fpiar);

    outbp += strlen(outbp);
}

static void hexdump(uint8_t* p, int len) {
    for (int i = 0; i < len; i++) {
        if (i > 0) *outbp++ = '.';
        sprintf(outbp, "%02x", p[i]);
        outbp += strlen(outbp);
    }
    *outbp++ = '\n';
}

static uint8_t last_exception[256];
static int last_exception_len;

static uint8_t* validate_exception(struct registers* regs, uint8_t* p, int excnum, int sameexc, int* experr) {
    int exclen = 0;
    uint8_t* exc;
    uint8_t* op = p;
    uint8_t* sp = (uint8_t*)regs->excframe;
    uint32_t v;
    uint8_t excdatalen = *p++;
    int size;

    if (!excdatalen) return p;
    exc = last_exception;
    if (excdatalen != 0xff) {
        if (cpu_level == 0) {
            if (excnum == 2 || excnum == 3) {
                // status (with undocumented opcode part)
                uint8_t opcode0 = p[1];
                uint8_t opcode1 = p[2];
                exc[0] = opcode0;
                exc[1] = (opcode1 & ~0x1f) | p[0];
                p += 3;
                // access address
                v = opcode_memory_addr;
                p = restore_rel_ordered(p, &v);
                pl(exc + 2, v);
                // opcode
                exc[6] = opcode0;
                exc[7] = opcode1;
                // sr
                exc[8] = regs->sr >> 8;
                exc[9] = regs->sr;
                // pc
                pl(exc + 10, regs->pc);
                exclen = 14;
            }
        } else if (cpu_level > 0) {
            // sr
            exc[0] = regs->sr >> 8;
            exc[1] = regs->sr;
            pl(exc + 2, regs->pc);
            const uint16_t t0 = *p++;
            const uint16_t t1 = *p++;
            // frame type
            uint16_t frame = (t0 << 8) | t1;
            exc[6] = frame >> 8;
            exc[7] = frame >> 0;

            switch (frame >> 12) {
                case 0:
                    exclen = 8;
                    break;
                case 2:
                    v = opcode_memory_addr;
                    p = restore_rel_ordered(p, &v);
                    pl(exc + 8, v);
                    exclen = 12;
                    break;
                case 3:
                    v = opcode_memory_addr;
                    p = restore_rel_ordered(p, &v);
                    pl(exc + 8, v);
                    exclen = 12;
                    break;
                case 4:
                    v = opcode_memory_addr;
                    p = restore_rel_ordered(p, &v);
                    pl(exc + 8, v);
                    v = opcode_memory_addr;
                    p = restore_rel_ordered(p, &v);
                    pl(exc + 12, v);
                    exclen = 16;
                    break;
                case 8:
                    exc[8] = *p++;
                    exc[9] = *p++;
                    v = opcode_memory_addr;
                    p = restore_rel_ordered(p, &v);
                    pl(exc + 10, v);
                    // data out
                    exc[16] = *p++;
                    exc[17] = *p++;
                    // data in
                    exc[20] = *p++;
                    exc[21] = *p++;
                    // inst
                    exc[24] = *p++;
                    exc[25] = *p++;
                    exc[14] = exc[15] = 0;
                    sp[14] = sp[15] = 0;
                    exc[18] = exc[19] = 0;
                    sp[18] = sp[19] = 0;
                    exc[22] = exc[23] = 0;
                    sp[22] = sp[23] = 0;
                    // ignore undocumented data
                    exclen = 26;
                    break;
                case 0x0a:
                case 0x0b:
                    exclen = 8;
                    break;
                default:
                    end_test();
                    printf("Unknown frame %04x\n", frame);
                    exit(0);
                    break;
            }
        }
        last_exception_len = exclen;
        if (p != op + excdatalen + 1) {
            end_test();
            printf("Exception length mismatch %d != %d\n", excdatalen, p - op - 1);
            exit(0);
        }
    } else {
        exclen = last_exception_len;
    }
    if (exclen == 0 || !sameexc) return p;
    if (memcmp(exc, sp, exclen)) {
        sprintf(outbp, "Exception %ld stack frame mismatch:\n", excnum);
        outbp += strlen(outbp);
        strcpy(outbp, "Expected: ");
        outbp += strlen(outbp);
        hexdump(exc, exclen);
        strcpy(outbp, "Got     : ");
        outbp += strlen(outbp);
        hexdump(sp, exclen);
        errors = 1;
        *experr = 1;
    }
    return p;
}

// regs: registers before execution of test code
// test_reg: registers used during execution of test code, also modified by test code.
// last_registers: registers after modifications from data files. Test ok if test_reg == last_registers.

static uint8_t* validate_test(uint8_t* p, int ignore_errors, int ignore_sr) {
    uint8_t regs_changed[16] = {0};
    uint8_t regs_fpuchanged[8] = {0};
    uint8_t sr_changed = 0, pc_changed = 0;
    uint8_t fpiar_changed = 0, fpsr_changed = 0, fpcr_changed = 0;
    int exc = -1;

    for (int i = 0; i < 16; i++) {
        if (last_registers.regs[i] != test_regs.regs[i]) {
            regs_changed[i] = 1;
        }
    }
    if ((last_registers.sr & test_ccrignoremask) != (test_regs.sr & test_ccrignoremask)) {
        sr_changed = 1;
    }
    if (last_registers.pc != test_regs.pc) {
        pc_changed = 1;
    }
    if (fpu_model) {
        for (int i = 0; i < 8; i++) {
            if (memcmp(&last_registers.fpuregs[i], &test_regs.fpuregs[i], sizeof(struct fpureg))) {
                regs_fpuchanged[i] = 1;
            }
        }
        if (last_registers.fpsr != test_regs.fpsr) {
            fpsr_changed = 1;
        }
        if (last_registers.fpcr != test_regs.fpcr) {
            fpcr_changed = 1;
        }
        if (last_registers.fpiar != test_regs.fpiar) {
            fpiar_changed = 1;
        }
    }

    if (*p == CT_END_SKIP) return p + 1;

    int experr = 0;
    for (;;) {
        uint8_t v = *p;
        if (v & CT_END) {
            exc = v & CT_EXCEPTION_MASK;
            int cpuexc = test_regs.exc & 65535;
            int cpuexc010 = test_regs.exc010 & 65535;
            p++;
            if ((v & CT_END_INIT) == CT_END_INIT) {
                end_test();
                printf("Unexpected CT_END_INIT %02x %08lx\n", v, p - test_data);
                endinfo();
                exit(0);
            }
            if (exc == 1) {
                end_test();
                printf("Invalid exception %02x\n", exc);
                endinfo();
                exit(0);
            }
            if (cpu_level > 0 && exc > 0 && cpuexc010 != cpuexc) {
                addinfo();
                if (dooutput) {
                    sprintf(outbp, "Exception: vector number does not match vector offset! (%d <> %d)\n", exc,
                            cpuexc010);
                    experr = 1;
                    outbp += strlen(outbp);
                    errors++;
                }
                break;
            }

            if (ignore_errors) {
                if (exc) {
                    p = validate_exception(&test_regs, p, exc, exc == cpuexc, &experr);
                }
                break;
            }
            if (exc == 0 && cpuexc == 4) {
                // successful complete generates exception 4 with matching PC
                if (last_registers.pc != test_regs.pc && dooutput) {
                    sprintf(outbp, "PC: expected %08lx but got %08lx\n", last_registers.pc, test_regs.pc);
                    outbp += strlen(outbp);
                    errors++;
                }
                break;
            }
            if (exc) {
                p = validate_exception(&test_regs, p, exc, exc == cpuexc, &experr);
            }
            if (exc != cpuexc) {
                addinfo();
                if (dooutput) {
                    if (cpuexc == 4 && last_registers.pc == test_regs.pc) {
                        sprintf(outbp, "Exception: expected %d but got no exception.\n", exc);
                    } else if (cpuexc == 4) {
                        sprintf(outbp, "Exception: expected %d but got %d (or no exception)\n", exc, cpuexc);
                    } else {
                        sprintf(outbp, "Exception: expected %d but got %d\n", exc, cpuexc);
                    }
                    experr = 1;
                }
                outbp += strlen(outbp);
                errors++;
            }
            break;
        }
        int mode = v & CT_DATA_MASK;

        if (mode < CT_AREG + 8 && (v & CT_SIZE_MASK) != CT_SIZE_FPU) {
            uint32_t val = last_registers.regs[mode];
            int size;
            p = restore_value(p, &val, &size);
            if (val != test_regs.regs[mode] && !ignore_errors) {
                addinfo();
                if (dooutput) {
                    sprintf(outbp, "%c%d: expected %08lx but got %08lx\n", mode < CT_AREG ? 'D' : 'A', mode & 7, val,
                            test_regs.regs[mode]);
                    outbp += strlen(outbp);
                }
                errors++;
            }
            regs_changed[mode] = 0;
            last_registers.regs[mode] = val;
        } else if (mode < CT_AREG && (v & CT_SIZE_MASK) == CT_SIZE_FPU) {
            struct fpureg val;
            p = restore_fpvalue(p, &val);
            if (memcmp(&val, &test_regs.fpuregs[mode], sizeof(struct fpureg)) && !ignore_errors) {
                addinfo();
                if (dooutput) {
                    sprintf(outbp, "FP%d: expected %04x-%08lx%08lx but got %04x-%08lx%08lx\n", mode, val.exp, val.m[0],
                            val.m[1], test_regs.fpuregs[mode].exp, test_regs.fpuregs[mode].m[0],
                            test_regs.fpuregs[mode].m[1]);
                    outbp += strlen(outbp);
                }
                errors++;
            }
            regs_fpuchanged[mode] = 0;
            memcpy(&last_registers.fpuregs[mode], &val, sizeof(struct fpureg));
        } else if (mode == CT_SR) {
            uint32_t val = last_registers.sr;
            int size;
            // High 16 bit: ignore mask, low 16 bit: SR/CCR
            p = restore_value(p, &val, &size);
            test_ccrignoremask = ~(val >> 16);

            if ((val & (sr_undefined_mask & test_ccrignoremask)) !=
                    (test_regs.sr & (sr_undefined_mask & test_ccrignoremask)) &&
                !ignore_errors && !ignore_sr) {
                addinfo();
                if (dooutput) {
                    sprintf(outbp, "SR: expected %04x -> %04x but got %04x (%04x)\n", test_sr & 0xffff, val & 0xffff,
                            test_regs.sr & 0xffff, test_ccrignoremask);
                    outbp += strlen(outbp);
                }
                errors++;
            }
            sr_changed = 0;
            last_registers.sr = val;
        } else if (mode == CT_PC) {
            uint32_t val = last_registers.pc;
            p = restore_rel(p, &val, 0);
            pc_changed = 0;
            last_registers.pc = val;
        } else if (mode == CT_FPCR) {
            uint32_t val = last_registers.fpcr;
            int size;
            p = restore_value(p, &val, &size);
            if (val != test_regs.fpcr && !ignore_errors) {
                addinfo();
                if (dooutput) {
                    sprintf(outbp, "FPCR: expected %08lx -> %08lx but got %08lx\n", test_fpcr, val, test_regs.fpcr);
                    outbp += strlen(outbp);
                }
                errors++;
            }
            fpcr_changed = 0;
            last_registers.fpcr = val;
        } else if (mode == CT_FPSR) {
            uint32_t val = last_registers.fpsr;
            int size;
            p = restore_value(p, &val, &size);
            if (val != test_regs.fpsr && !ignore_errors) {
                addinfo();
                if (dooutput) {
                    sprintf(outbp, "FPSR: expected %08lx -> %08lx but got %08lx\n", test_fpsr, val, test_regs.fpsr);
                    outbp += strlen(outbp);
                }
                errors++;
            }
            fpsr_changed = 0;
            last_registers.fpsr = val;
        } else if (mode == CT_FPIAR) {
            uint32_t val = last_registers.fpiar;
            p = restore_rel(p, &val, 0);
            if (val != test_regs.fpiar && !ignore_errors) {
                addinfo();
                if (dooutput) {
                    sprintf(outbp, "FPIAR: expected %08x but got %08x\n", val, test_regs.fpiar);
                    outbp += strlen(outbp);
                }
                errors++;
            }
            fpiar_changed = 0;
            last_registers.fpiar = val;

        } else if (mode == CT_MEMWRITES) {
            p = restore_memory(p, 0);
        } else if (mode == CT_MEMWRITE) {
            uint8_t* addr;
            uint32_t val = 0, mval = 0, oldval = 0;
            int size;
            p = get_memory_addr(p, &addr);
            p = restore_value(p, &oldval, &size);
            p = restore_value(p, &val, &size);
            switch (size) {
                case 0:
                    mval = addr[0];
                    if (mval != val && !ignore_errors) {
                        addinfo();
                        if (dooutput) {
                            sprintf(outbp, "Memory byte write: address %08lx, expected %02x but got %02x\n",
                                    (uint32_t)addr, val, mval);
                            outbp += strlen(outbp);
                        }
                        errors++;
                    }
                    addr[0] = oldval;
                    break;
                case 1:
                    mval = (addr[0] << 8) | (addr[1]);
                    if (mval != val && !ignore_errors) {
                        addinfo();
                        if (dooutput) {
                            sprintf(outbp, "Memory word write: address %08lx, expected %04x but got %04x\n",
                                    (uint32_t)addr, val, mval);
                            outbp += strlen(outbp);
                        }
                        errors++;
                    }
                    addr[0] = oldval >> 8;
                    addr[1] = oldval;
                    break;
                case 2:
                    mval = gl(addr);
                    if (mval != val && !ignore_errors) {
                        addinfo();
                        if (dooutput) {
                            sprintf(outbp, "Memory long write: address %08lx, expected %08lx but got %08x\n",
                                    (uint32_t)addr, val, mval);
                            outbp += strlen(outbp);
                        }
                        errors++;
                    }
                    pl(addr, oldval);
                    break;
            }
        } else {
            end_test();
            printf("Unknown test data %02x mode %d\n", v, mode);
            exit(0);
        }
    }
    if (!ignore_errors) {
        if (!ignore_sr) {
            for (int i = 0; i < 16; i++) {
                if (regs_changed[i]) {
                    addinfo();
                    if (dooutput) {
                        sprintf(outbp, "%c%d: modified %08lx -> %08lx but expected no modifications\n",
                                i < 8 ? 'D' : 'A', i & 7, last_registers.regs[i], test_regs.regs[i]);
                        outbp += strlen(outbp);
                    }
                    errors++;
                }
            }
            if (sr_changed) {
                addinfo();
                if (dooutput) {
                    sprintf(outbp, "SR: modified %04x -> %04x but expected no modifications\n",
                            last_registers.sr & 0xffff, test_regs.sr & 0xffff);
                    outbp += strlen(outbp);
                }
                errors++;
            }
        }
        for (int i = 0; i < 8; i++) {
            if (regs_fpuchanged[i]) {
                addinfo();
                if (dooutput) {
                    sprintf(outbp, "FP%d: modified %04x-%08lx%08lx -> %04x-%08lx%08lx but expected no modifications\n",
                            i, last_registers.fpuregs[i].exp, last_registers.fpuregs[i].m[0],
                            last_registers.fpuregs[i].m[1], test_regs.fpuregs[i].exp, test_regs.fpuregs[i].m[0],
                            test_regs.fpuregs[i].m[1]);
                    outbp += strlen(outbp);
                }
                errors++;
            }
        }
        if (fpsr_changed) {
            addinfo();
            if (dooutput) {
                sprintf(outbp, "FPSR: modified %08x -> %08x but expected no modifications\n", last_registers.fpsr,
                        test_regs.fpsr);
                outbp += strlen(outbp);
            }
            errors++;
        }
        if (fpcr_changed) {
            addinfo();
            if (dooutput) {
                sprintf(outbp, "FPCR: modified %08x -> %08x but expected no modifications\n", last_registers.fpcr,
                        test_regs.fpcr);
                outbp += strlen(outbp);
            }
            errors++;
        }
        if (fpiar_changed) {
            addinfo();
            if (dooutput) {
                sprintf(outbp, "FPIAR: modified %08x -> %08x but expected no modifications\n", last_registers.fpiar,
                        test_regs.fpiar);
                outbp += strlen(outbp);
            }
            errors++;
        }
    }
    if (errors && dooutput) {
        addinfo();
        if (!fpu_model) {
            strcat(outbp, "Registers before:\n");
            outbp += strlen(outbp);
        }
        out_regs(&regs, 1);
        if (!fpu_model) {
            strcat(outbp, "Registers after:\n");
            outbp += strlen(outbp);
        }
        out_regs(&test_regs, 0);
        if (exc > 1) {
            if (!experr) {
                sprintf(outbp, "OK: Generated exception %d\n", exc);
                outbp += strlen(outbp);
            }
            if ((exc == 3 || exc == 2) && cpu_level == 0) {
                sprintf(outbp, "RW=%d IN=%d FC=%d\n", ((test_regs.exc >> (16 + 4)) & 1),
                        ((test_regs.exc >> (16 + 3)) & 1), ((test_regs.exc >> (16 + 0)) & 7));
                outbp += strlen(outbp);
            }
        } else if (exc == 0 && (test_regs.exc & 65535) == 4) {
            sprintf(outbp, "OK: No exception generated\n");
            outbp += strlen(outbp);
        }
    }
    return p;
}

static void store_addr(uint32_t s, uint8_t* d) {
    if (s == 0xffffffff) return;
    for (int i = 0; i < SIZE_STORED_ADDRESS; i++) {
        uint32_t ss = s + (i - SIZE_STORED_ADDRESS_OFFSET);
        if (is_valid_test_addr(ss)) {
            *d++ = *((uint8_t*)ss);
        } else {
            *d++ = 0;
        }
    }
}

static void process_test(uint8_t* p) {
    outbp = outbuffer;
    outbp[0] = 0;
    infoadded = 0;
    errors = 0;

    memset(&regs, 0, sizeof(struct registers));
    regs.sr = interrupt_mask << 8;
    regs.srcaddr = 0xffffffff;
    regs.dstaddr = 0xffffffff;

    start_test();

    test_ccrignoremask = 0xffff;
    ahcnt = 0;

    for (;;) {
#ifndef M68K
        outbp = outbuffer;
#endif

        for (;;) {
            uint8_t v = *p;
            if (v == CT_END_INIT || v == CT_END_FINISH) break;
            p = restore_data(p);
        }
        if (*p == CT_END_FINISH) break;
        p++;

        store_addr(regs.srcaddr, srcaddr);
        store_addr(regs.dstaddr, dstaddr);

        memcpy(&last_registers, &regs, sizeof(struct registers));

        int fpumode = fpu_model && (opcode_memory[0] & 0xf0) == 0xf0;

        if (cpu_level >= 2) flushcache(cpu_level);

        uint32_t pc = opcode_memory_addr;

        int extraccr = 0;

        uint32_t last_pc = opcode_memory_addr;
        uint32_t last_fpiar = opcode_memory_addr;
        int old_super = -1;

        for (;;) {
            uint16_t sr_mask = 0;

            if (extraccr & 1) sr_mask |= 0x2000;  // S
            if (extraccr & 2) sr_mask |= 0x4000;  // T0
            if (extraccr & 4) sr_mask |= 0x8000;  // T1
            if (extraccr & 8) sr_mask |= 0x1000;  // M

            int maxccr = *p++;
            for (int ccr = 0; ccr < maxccr; ccr++) {
                regs.ssp = super_stack_memory - 0x80;
                regs.msp = super_stack_memory;
                regs.pc = opcode_memory_addr;
                regs.fpiar = opcode_memory_addr;

#ifdef M68K
                memcpy((void*)regs.ssp, (void*)regs.regs[15], 0x20);
#endif
                memcpy(&test_regs, &regs, sizeof(struct registers));

                if (maxccr >= 32) {
                    test_regs.sr = ccr;
                } else {
                    test_regs.sr = (ccr ? 31 : 0);
                }
                test_regs.sr |= sr_mask | (interrupt_mask << 8);
                test_sr = test_regs.sr;
                if (fpumode) {
                    if (maxccr >= 32) {
                        test_regs.fpsr = (ccr & 15) << 24;
                        test_regs.fpcr = (ccr >> 4) << 4;
                    } else {
                        test_regs.fpsr = (ccr ? 15 : 0) << 24;
                        test_regs.fpcr = (ccr >> 1) << 4;
                    }
                    test_fpsr = test_regs.fpsr;
                    test_fpcr = test_regs.fpcr;
                }
                int super = (test_regs.sr & 0x2000) != 0;

                if (super != old_super) {
                    stackaddr_ptr = super ? regs.ssp : regs.regs[15];
                    store_addr(stackaddr_ptr, stackaddr);
                    old_super = super;
                }

                if ((*p) == CT_END_SKIP) {
                    p++;

                } else {
                    int ignore_errors = 0;
                    int ignore_sr = 0;

                    if ((ccr_mask & ccr) || (ccr == 0)) {
                        reset_error_vectors();

                        if (cpu_level == 1) {
                            execute_test010(&test_regs);
                        } else if (cpu_level >= 2) {
                            if (fpu_model)
                                execute_testfpu(&test_regs);
                            else
                                execute_test020(&test_regs);
                        } else {
                            execute_test000(&test_regs);
                        }

                        if (ccr_mask == 0 && ccr == 0) ignore_sr = 1;

                        //set_error_vectors();

                    } else {
                        test_regs.sr = test_sr;
                        ignore_errors = 1;
                        ignore_sr = 1;
                    }

                    last_registers.pc = last_pc;
                    last_registers.fpiar = last_fpiar;

                    if ((*p) == CT_SKIP_REGS) {
                        p++;
                        for (int i = 0; i < 16; i++) {
                            test_regs.regs[i] = regs.regs[i];
                        }
                    }

                    p = validate_test(p, ignore_errors, ignore_sr);

                    last_pc = last_registers.pc;
                    last_fpiar = last_registers.fpiar;
                }

                testcnt++;

                if (testexit()) {
                    end_test();
                    printf("\nAborted (%ld)\n", testcnt);
                    exit(0);
                }

#if DONTSTOPONERROR == 0
                if (quit || errors) goto end;
#endif
            }

            if (*p == CT_END) {
                p++;
                break;
            }

            extraccr = *p++;
        }

        restoreahist();
    }

end:
    end_test();

    if (infoadded) {
        printf("\n");
        printf(outbuffer);
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

MK68LoadResult M68KCpuTester_load_opcode(const M68KTesterRunSettings* options, const char* opcode, const char* path) {
    MK68LoadResult load_result = {0};
    char full_path[4096] = {0};
    char filename[4096] = {0};
    uint8_t data[4] = {0};
    int size = 0;
    uint32_t v = 0;
    int filecnt = 1;
    uint32_t start_time_id;
    int lvl = 0;

    join_path(full_path, path, opcode, sizeof(full_path));
    sprintf(filename, "%s/0000.dat", full_path);

    FILE* f = fopen(filename, "rb");

    if (!f) {
        load_result.error = get_error_string("Couldn't open '%s'\n", filename);
        return load_result;
    }

    uint32_t data_version = read_u32(f, filename);

    if (data_version != M68K_DATA_VERSION) {
        fclose(f);
        load_result.error = get_error_string("Data file %s doesn't match expected version (%d) but was %d", filename,
                                             M68K_DATA_VERSION, v);
        return load_result;
    }

    M68KTesterContext* context = malloc_zero(sizeof(M68KTesterContext));

    // setup all the data

    context->version = data_version;
    context->start_time_id = read_u32(f, filename);
    uint32_t hlmem_rom = read_u32(f, filename);

    context->test_memory.start = read_u32(f, filename);
    context->test_memory.size = read_u32(f, filename);
    context->test_memory.end = context->test_memory.start + context->test_memory.size;

    context->opcode_memory_address = read_u32(f, filename);

    uint32_t flags = read_u32(f, filename);
    context->fpu_model = read_u32(f, filename);

    context->low_memory.start = read_u32(f, filename);
    context->low_memory.end = read_u32(f, filename);
    context->low_memory.size = context->low_memory.end - context->low_memory.start;

    context->high_memory.start = read_u32(f, filename);
    context->high_memory.end = read_u32(f, filename);
    context->high_memory.size = context->high_memory.end - context->high_memory.start;

    context->safe_memory_start = read_u32(f, filename);
    context->safe_memory_end = read_u32(f, filename);

    fseek(f, 8, SEEK_CUR);  // skip unsed
    read_data(context->name, f, M68K_INST_NAME_SIZE, filename);

    // Patch up the data after the initial loading is complete

    context->high_mem_rom = (uint16_t)(hlmem_rom >> 16);
    context->low_mem_rom = (uint16_t)(hlmem_rom & 0xffff);

    context->cpu_level = (flags >> 16) & 15;
    context->interrupt_mask = (flags >> 20) & 7;
    context->addressing_mask = (flags & 0x80000000) ? 0xffffffff : 0x00ffffff;
    context->flag_mode = (flags >> 30) & 1;
    context->sr_undefined_mask = flags & 0xffff;

    // const int lvl = context->cpu_levels;
    /*
        int lvl2 = selected_cpu_level;
        if (lvl2 == 5 && lvl2 != lvl)
                lvl2 = 4;

        if (lvl != lvl2) {
                load_result.error = get_error_string("Mismatched CPU model: %lu <> %lu\n",
                        68000 + 10 * (cpu_level < 5 ? cpu_level : 6), 68000 + (lvl < 5 ? lvl : 6) * 10);
                return load_result;
        }
        */

    if (!options->check_undefined_sr) {
        context->sr_undefined_mask = ~context->sr_undefined_mask;
    } else {
        context->sr_undefined_mask = 0xffff;
    }

    // Calculate the offsets to use
    if (context->low_memory.start != 0xffffffff) context->low_memory.offset = context->low_memory.start;
    if (context->high_memory.start != 0xffffffff) context->high_memory.offset = context->high_memory.start & 0x7fff;

    // Load the memory files

    if (!load_memory_file(&context->low_memory, path, "lmem.dat")) {
        load_result.error = get_error_string("Unable to load lmem.dat in path %s", path);
        return load_result;
    }

    if (!load_memory_file(&context->high_memory, path, "hmem.dat")) {
        load_result.error = get_error_string("Unable to load hmem.dat in path %s", path);
        return load_result;
    }

    if (!load_memory_file(&context->test_memory, path, "tmem.dat")) {
        load_result.error = get_error_string("Unable to load tmem.dat in path %s", path);
        return load_result;
    }

    context->opcode_memory =
        (uint8_t*)context->test_memory.buffer + context->opcode_memory_address - context->test_memory.start;

    // context->opcode_memory = context->test_memory.memory +
    //	(context->opcode_memory_address - context->test_memory.buffer);

    load_result.context = context;
    return load_result;
}

int main() {
    M68KTesterRunSettings options = {0};

    MK68LoadResult load = M68KCpuTester_load_opcode(&options, "MOVE.W", "data/68000/");

    if (load.error) {
        printf("%s:%d failed to load data: %s\n", __FILE__, __LINE__, load.error);
        return 1;
    }

    M68KCpuTester_debug_print(load.context);

    return 0;
}
